---
title: CS_168_1
author: MrSibe
pubDatetime: 2025-01-01T00:00:00Z
slug: cs_168_1
featured: false
draft: false
description: Learn about cs_168_1 with detailed explanations and examples.

---
## 一、互联网导论

### 互联网是什么？

互联网不是我们平时打开浏览器看到的花花绿绿的网页，那只是互联网应用的一部分——万维网。电子邮件、我的世界游戏服务器，甚至物联网设备都算互联网的一份子。

### 互联网为什么有趣 ？

计算机网络学起来很难，是因为平时学的课程，比如编程语言，或者是计算机组成或者数据库，他们的设计范式基本一致（比如抽象思想、面向对象编程等等）。而计算机网络是一个非常新颖的计算机科学领域，我们需要用一个新的设计范式来解决如何联系全世界的电脑这个问题。我们不追求互联网的最优解，我们需要权衡很多因素，以此构造一个适用的、可扩展的互联网系统。

### 互联网是联盟式的、可扩展的

互联网由很多运营商（ISP）在维护，每个运营商独立运作，但每个运营商都必须合作以连接整个世界。因此运营商们必须达成一致的协议，才能让互联网遍布世界的每一个角落。

互联网不是“金字塔层级”，也就是不是只有一个运营商，因此我们互联网需要做的就是把各个运营商链接在一起，每个局域网连接在一起，每个设备连接在一起... 这就是互联网的可扩展性。

庞大体积也给互联网本身带来很多挑战，比如消息可能在传输中途就失效了，再比如中途有一个或者很多个路由器坏了等等，因此互联网需要面对随机和众多的故障。

### 协议

这节课的重点在于协议。协议就是一种标准，规定了互联网中的数据以什么方式、格式传输，从哪传送到哪，这样才能保证一致性。协议一般是以请求评论（RFC）的方式发布的，由 IETF 负责。

## 二、互联网层次

### 第一层：物理层

物理层的作用就是把**位信息**通过某种方式传输出去。这种方式通常有电线上的电压、无线无线电波、光纤电缆中的光脉冲等，这是电气领域的事情，是计算机网络的最低层次，我们不作深究。

### 第二层：数据链路层

在互联网中，一条链路连接两台机器，多条链路连接多台机器构成了**局域网（local area network，LAN)**。

链路层主要是把物理层的位信息分组成**数据包（packets）**（有时候也叫帧frames），以其作为基本单位，并定义物理信号中数据包的起始和结束位置。

### 第三层：网络层

不同局域网的设备想要沟通，就必须搭建局域网之间的桥梁，不同的局域网连接起来就构成了互联网。这个桥梁的两个端点就是**交换器（switch）** 或者 **路由器（router）**。

互联网层解决了以下问题：

1. 交换机或者路由器收到数据包，该往哪里转发？怎么发路径最短？（路由单元的重点）
2. 如何保证链路上有足够的容量来传输我们的数据？（拥塞控制单元的重点）

网络层的两个特性是：

1. 尽力而为传输：只管传输，不管有没有传输到，尽力就好。
2. 数据包抽象：如果传输大量数据，就把它切分成多个小数据包传输。

### 第四层：传输层

传输层以第三层网络层为基础，实现了一个额外的**协议**，用于重传丢失的数据包、将数据分割成数据包，以及重新排序乱序到达的数据包（以及其他功能）。

传输层协议使我们能够停止以数据包为单位思考，转而以**流**的形式思考，即两个端点之间交换的**数据包流**。

### 第七层：应用层

应用层使得互联网可以支持不同的应用，例如收邮件，下载视频等等。如果没有第七层，恐怕互联网就只能有一种用途，换句话说应用层使得互联网有更多的应用。

![{6C0F8233-085A-446C-B61A-4219906F466A}.png](https://raw.githubusercontent.com/MrSibe/obsidian_images/main/%7B6C0F8233-085A-446C-B61A-4219906F466A%7D.png)

会话层（第五层）原本应该将不同的数据流组装成一个会话（例如，加载各种图像和广告来形成一个网页），而表示层（第六层）原本应该帮助用户可视化数据。如今，这些层的功能主要在第七层中实现，因此直接被跳过了。

## 三、报头

### 为什么需要报头

在第三层网络层我们提出了一个问题：数据包应该经过什么路径发送？

这件事关乎交换机或者路由器，我们应该提前告诉他们这个数据包往哪发送。实现方法就是在数据前面加上**报头（headers）**。而数据在这里我们就叫它**载荷（payload）**。

![{2983D271-4492-4366-8ED4-78F43509FEED}.png](https://raw.githubusercontent.com/MrSibe/obsidian_images/main/%7B2983D271-4492-4366-8ED4-78F43509FEED%7D.png)

每一个网络设备都需要遵循一个报头标准，就像世界通用一个语言——英语，这样数据包的传输才不会乱套。

### 报头里有什么信息

1. 目标地址：告诉路由器和交换器，数据包要往何处发送。
2. 源地址：允许数据接收方可以回信。
3. 校验和：确保数据包在传输中途没有损坏。
4. 其他元数据：例如数据包的长度。

### 报头疯狂嵌套

信息顺着互联网层次越低，修饰的报头就越多；层次越高，报头就越少。

每一个设备都会处理前三层：物理层、数据链路层和网络层，但只有发信和收信的主机才可以处理后两层：传输层和应用层。经过这样不停的拆包和封装过程，数据最终被传输到目的地址。

第一层、第二层的协议可以采用无线或者有线方式传输，但是必须和上一跳或者下一跳的协议一样；第四层和第七层中，发送主机和目标主机的协议必须完全一样，以保证功能相同。

## 三、网络架构

### 设计范式

上一节我们自底向上了解了互联网层次，现在我们自顶向下来认识互联网设计采用的范式。

互联网的范式有很多也很有争议，比如联盟式（独立运营商合作），但在近年来，软件定义网络（SDN）作为一种更集中的网络管理方式出现。

### “楚王好细腰”

互联网层次中的一层可以只有一个协议，也可以有很多很多协议。

![](https://raw.githubusercontent.com/MrSibe/obsidian_images/main/%7B3EB4AD68-040E-47B5-8BAB-17F14BDF8A28%7D.png)

现代互联网的协议如上图所示，形成了一个上下宽中间窄的图像。可以发现在第三层只有 IP 协议，互联网的每一个人都必须使用 IP 协议才能传输数据。

### 解复用

上面说到，多个协议可能采用同一个路径传递，因此在第四层解包的时候我们要在报头中声明，下一个协议具体是什么协议（TCP/UDP）；而在第七层我们需要声明下一个端口是什么。端口用来区分数据包属于哪个应用程序。

端口分为逻辑端口和物理端口。逻辑端口就是报头里面的 port 字段；物理端口就是交换机上插的网线物理位置。

注意：套接字（socket）指的是操作系统用于将应用程序连接到操作系统中的网络栈的机制。当应用程序打开一个套接字时，该套接字将与一个逻辑端口号相关联。当操作系统接收到一个数据包时，它使用端口号将该数据包定向到相关联的套接字。

### 端到端原则

端到端原则，说白了就是让互联网的底层专注于数据传输，而高层主要作服务。这个思想为设计互联网提供了智慧和指导，指导着关于网络实现哪些功能、不实现哪些功能的讨论。这里具体不细究。

## 资源共享设计

### 统计复用

之前在第三层提出了第二个问题：交换机和路由器容量有限，如何在不同互联网用户之间共享这些资源？

答案是：网络资源是**统计复用**的，这意味着我们会**根据用户的需求动态分配资源**，而不是将固定份额的资源分配给用户。

![{D2E5042C-D245-43D1-A025-47B5C83CFCCF}.png](https://raw.githubusercontent.com/MrSibe/obsidian_images/main/%7BD2E5042C-D245-43D1-A025-47B5C83CFCCF%7D.png)

统计复用能够工作的前提是：**在实践中，总需求的峰值远小于各峰值需求的总和。**

![{6EE0A2E7-3354-4658-80A6-9BAB9357A102}.png](https://raw.githubusercontent.com/MrSibe/obsidian_images/main/%7B6EE0A2E7-3354-4658-80A6-9BAB9357A102%7D.png)

统计复用是一种具有权衡的设计选择，我们不会为最坏情况（所有需求同时达到峰值）进行配置。峰值仍可能同时发生，这将导致数据包延迟或丢失。

### 电路交换 VS 分组交换

我们可以使用**统计复用**来决定建设多少容量。我们的下一个问题是：我们实际上是如何在用户之间动态分配资源的？

网络共享资源的方式有两种：

1. **尽力而为**：数据包发出去就不管了。尽力而为的最佳设计称为**分组交换**：交换机独立地查看每个分组，并将分组转发到离目的地更近的地方。交换机不会考虑流或预留。
2. **预留**：在流开始时，用户明确请求并预留所需的带宽。数据发送完毕后，资源可以被释放供其他人预留。预留的最佳设计，称为**电路交换**。两台主机直接搭建好数据传递的通道之后再进行传输。

![{40E1B8B1-F3DD-4C8B-BC75-A2D3ABE87C59}.png](https://raw.githubusercontent.com/MrSibe/obsidian_images/main/%7B40E1B8B1-F3DD-4C8B-BC75-A2D3ABE87C59%7D.png)

![{434360BD-CE9C-4C10-8EE4-744B5DA1DCE4}.png](https://raw.githubusercontent.com/MrSibe/obsidian_images/main/%7B434360BD-CE9C-4C10-8EE4-744B5DA1DCE4%7D.png)

电路交换和分组交换都体现了统计复用。主要区别在于我们分配资源的粒度：**预留按流分配，尽力而为按包分配。** 即使在电路交换中，我们也是根据预留动态分配资源。我们不是预先为所有可能存在的流进行预留。

### 电路交换与分组交换的权衡

为了比较两者，我们作四个维度的比较：

#### 1. 能否提供给应用程序开发者的抽象 ？

电路交换为开发者提供了更有用的抽象，因为可以保证预留的带宽，网络的行为可以预测。对于网络运营商来说，更方便统计流量，方便收费。

#### 2. 资源利用效率如何？

分组交换通常更高效。如果每个发送者在整个时间段内以恒定速率发送数据，那么电路交换和分组交换都能充分利用容量；如果每个发送者的速率随时间变化，那么分组交换能更好地利用带宽。

![{89EE3DEF-DC0D-493B-91EC-8CA8B3A42512}.png](https://raw.githubusercontent.com/MrSibe/obsidian_images/main/%7B89EE3DEF-DC0D-493B-91EC-8CA8B3A42512%7D.png)

一个数据流的突发性是由其峰值速率与平均速率的比值定义的。语音通话通常具有较平滑的比值，如 3:1，而网页浏览通常具有较突发的比值，如 100:1。

分组交换更高效的原因之二是：电路交换在建立和拆除电路时需要额外的时间。这对于非常短的数据尤其低效。

#### 3. 处理故障的效果如何？

分组交换在规模上处理故障方面表现更好。如果路由器发生故障，我们可以将数据包沿网络中的其他路径发送。

#### 4. 实现有多复杂？

状态一致性问题导致电路交换非常复杂。所有路由器要保证同时接通，都必须跟踪额外的状态并保持一致。

总之：电路交换通过预留带宽为应用提供更好的性能，同时也为开发者提供更可预测的行为。分组交换能更有效地共享带宽，并避免启动时间，更容易从故障中恢复，更易于实现。

### 在现实中...

分组交换是默认的资源共享方法，但是在专用网络中电路交换用的比较多。

## 链接

### 链接的属性

1. 带宽（bandwidth）：告诉我们每单位时间内可以在链路上发送多少比特，单位通常用比特每秒（bps）。
2. 传播延迟（propagation delay）：一个比特沿链路传输需要多长时间。
3. 带宽延迟积（BDP）：带宽和传播延迟的乘积，直观上这是链路的容量。

### 时序图

假设我们有一条带宽为 1 Mbps = 每秒 100 万比特，传播延迟为 1 ms = 0.001 秒的链路。发送一个 bit 需要 0.000001 秒，时序图如下：

![{EA69C190-0080-4ACC-B327-177450EA173F}.png](https://raw.githubusercontent.com/MrSibe/obsidian_images/main/%7BEA69C190-0080-4ACC-B327-177450EA173F%7D.png)

假如发送 800 个 bits，时序图如下：

![{03846435-24F5-4343-9073-C2DCDA829188}.png](https://raw.githubusercontent.com/MrSibe/obsidian_images/main/%7B03846435-24F5-4343-9073-C2DCDA829188%7D.png)

### 数据包延迟

**数据包延迟**是指整个数据包从第一个比特被放到线路上开始，到最后一个比特在另一端被接收为止所需要的时间。这种延迟是传输延迟和传播延迟的总和。

传输延迟告诉我们将比特放到线路上需要多长时间，通常是数据包大小除以链路带宽。

我们权衡带宽和传播延迟主要看数据包延迟。带宽越大，传输延迟越小。

### 管道图

还有一种管道图也可以表示链路：

![{2880F008-1D2A-4821-9CC3-9999A9FCFF60}.png](https://raw.githubusercontent.com/MrSibe/obsidian_images/main/%7B2880F008-1D2A-4821-9CC3-9999A9FCFF60%7D.png)

![{3215DA70-3D60-4ED2-8E4A-667C68FD1483}.png](https://raw.githubusercontent.com/MrSibe/obsidian_images/main/%7B3215DA70-3D60-4ED2-8E4A-667C68FD1483%7D.png)

### 重载链接

当同时有两个数据包到达路由器，其中一个数据包会通过路由器处理，另外一个则放在路由器的队列里面，这也会导致延迟。因此，**数据包延迟是传输延迟、传播延迟和排队延迟的总和**。
